#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <ctype.h>  


#define MAX_DIM 3
#define EPSILON 1e-9
#define MAX_ITER 1000

// Declaração de protótipos de funções
void limparTela();
void Menu();
void limparArquivo();
void LerArquivo();
void imprimirMatriz(int dim, double mat[MAX_DIM][MAX_DIM], FILE *arquivo);
void imprimirMatrizComSolucoes(int dim, double mat[MAX_DIM][MAX_DIM + 1], double sol[MAX_DIM], int exibirSolucoes, FILE *arquivo);
int extrairCoeficientes2x2(char* equacao, double* coef);
int extrairCoeficientes3x3(char* equacao, double* coef);
int eliminacaoGauss(int dim, double mat[MAX_DIM][MAX_DIM + 1], double sol[MAX_DIM]);
void executarSistema();
int eliminacaoGaussMatriz(int dim, double mat[MAX_DIM][MAX_DIM]);
int Injetividade();
double determinante2x2(double mat[2][2]);
double determinante3x3(double mat[3][3]);
int verificarBase(int dim, double vetores[MAX_DIM][MAX_DIM]);
int base();
void multiplicarMatrizVetor(int dim, double mat[MAX_DIM][MAX_DIM], double vetor[MAX_DIM], double resultado[MAX_DIM]);
void normalizarVetor(int dim, double vetor[MAX_DIM]);
double calcularAutovalorAutovetor(int dim, double mat[MAX_DIM][MAX_DIM], double vetor[MAX_DIM]);
void deflacionarMatriz(int dim, double mat[MAX_DIM][MAX_DIM], double autovalor, double autovetor[MAX_DIM]);
void calcularTodosAutovaloresAutovetores(int dim, double mat[MAX_DIM][MAX_DIM], double autovalores[MAX_DIM], double autovetores[MAX_DIM][MAX_DIM]);
void imprimirMatrizDiagonal(int dim, double autovalores[MAX_DIM]);
int autovetores();
void diagonalizar(int dim, double mat[MAX_DIM][MAX_DIM], FILE *arquivo);
int diagonalizarExecute();

int main() {
    int escolha;

    do {
        printf("====================================\n");
        printf("     ALGEBRA LINEAR EXECUTADOR       \n");
        printf("====================================\n");
        printf("Escolha uma opcao:\n");
        printf("1 - Resolucao de Sistemas Lineares\n");
        printf("2 - Verificacao de Injetividade, Sobrejetividade e Bijetividade\n");
        printf("3 - Determinacao de Bases\n");
        printf("4 - Calculo de Autovalores e Autovetores\n");
        printf("5 - Diagonalizacao de Matrizes\n");
        printf("6 - Historico\n");
        printf("7 - Limpar Historico\n");
        printf("8 - Sair\n");
        printf("Digite sua escolha: ");

        if (scanf("%d", &escolha) != 1) {
            printf("Opcao invalida. Tente novamente.\n");
            while (getchar() != '\n');
            continue;
        }

        switch (escolha) {
            case 1:
                executarSistema();
                break;
            case 2:
                Injetividade();
                break;
            case 3:
                base();
                break;
            case 4:
                autovetores();
                break;
            case 5:
                diagonalizarExecute();
                break;
            case 6:
                LerArquivo();
                break;
            case 7:
                limparArquivo();
                break;
            case 8:
                printf("Saindo...\n");
                break;
            default:
                printf("Opcao invalida. Tente novamente.\n");
                break;
        }
    } while (escolha != 8);

    return 0;
}

// Funções de utilidade
void limparTela() {
#ifdef _WIN32
    system("cls");
#else
    system("clear");
#endif
}

void Menu() {
    int opcao;
    do {
        printf("\nDigite 1 para voltar ao menu: ");
        if (scanf("%d", &opcao) != 1) {
            printf("Entrada invalida. Tente novamente.\n");
            while (getchar() != '\n');
            opcao = 0;
        }
    } while (opcao != 1);
    limparTela();
}

void limparArquivo() {
    FILE *arquivo = fopen("main.txt", "w");
    if (arquivo == NULL) {
        printf("Erro ao abrir o arquivo para limpar!\n");
        return;
    }
    fclose(arquivo);
    limparTela();
    printf("Historico limpo com sucesso.\n\n");
}

void LerArquivo() {
    limparTela();
    FILE *arquivo = fopen("main.txt", "r");
    if (arquivo == NULL) {
        printf("Erro ao abrir o arquivo para leitura!\n");
        return;
    }
    char linha[256];
    printf("\n====================================\n");
    printf("          HISTORICO DE OPERACOES          \n");
    printf("====================================\n\n");
    while (fgets(linha, sizeof(linha), arquivo) != NULL) {
        printf("%s", linha);
    }
    fclose(arquivo);
    Menu();
}

void imprimirMatriz(int dim, double mat[MAX_DIM][MAX_DIM], FILE *arquivo) {
    for (int i = 0; i < dim; i++) {
        printf("| ");
        fprintf(arquivo, "| ");
        for (int j = 0; j < dim; j++) {
            printf("%6.2f ", mat[i][j]);
            fprintf(arquivo, "%6.2f ", mat[i][j]);
        }
        printf("|\n");
        fprintf(arquivo, "|\n");
    }
    printf("\n");
    fprintf(arquivo, "\n");
}

void imprimirMatrizComSolucoes(int dim, double mat[MAX_DIM][MAX_DIM + 1], double sol[MAX_DIM], int exibirSolucoes, FILE *arquivo) {
    for (int i = 0; i < dim; i++) {
        printf("| ");
        fprintf(arquivo, "| ");
        for (int j = 0; j < dim; j++) {
            printf("%6.2f ", mat[i][j]);
            fprintf(arquivo, "%6.2f ", mat[i][j]);
        }
        printf("| %6.2f ", mat[i][dim]);
        fprintf(arquivo, "| %6.2f ", mat[i][dim]);

        if (exibirSolucoes) {
            if (dim == 2) {
                if (i == 0) {
                    printf("| x = %.2f", sol[0]);
                    fprintf(arquivo, "| x = %.2f", sol[0]);
                } else if (i == 1) {
                    printf("| y = %.2f", sol[1]);
                    fprintf(arquivo, "| y = %.2f", sol[1]);
                }
            } else if (dim == 3) {
                if (i == 0) {
                    printf("| x = %.2f", sol[0]);
                    fprintf(arquivo, "| x = %.2f", sol[0]);
                } else if (i == 1) {
                    printf("| y = %.2f", sol[1]);
                    fprintf(arquivo, "| y = %.2f", sol[1]);
                } else if (i == 2) {
                    printf("| z = %.2f", sol[2]);
                    fprintf(arquivo, "| z = %.2f", sol[2]);
                }
            }
        }

        printf(" |\n");
        fprintf(arquivo, " |\n");
    }
    printf("\n");
    fprintf(arquivo, "\n");
}

// Funções para resolução de sistemas lineares
int extrairCoeficientes2x2(char* equacao, double* coef) {
    int encontrouX = 0, encontrouY = 0, encontrouIgual = 0;
    char* ptr = equacao;
    coef[0] = coef[1] = coef[2] = 0;
    double valor;
    int sinal = 1;

    while (*ptr != '\0') {
        if (*ptr == ' ') {
            ptr++;
            continue;
        }
        if (*ptr == '+') {
            sinal = 1;
            ptr++;
        } else if (*ptr == '-') {
            sinal = -1;
            ptr++;
        } else if (isdigit(*ptr) || *ptr == '.') {
            valor = strtod(ptr, &ptr);
            valor *= sinal;
            sinal = 1;
            if (*ptr == 'x') {
                coef[0] += valor;
                encontrouX = 1;
                ptr++;
            } else if (*ptr == 'y') {
                coef[1] += valor;
                encontrouY = 1;
                ptr++;
            } else if (encontrouIgual) {
                coef[2] += valor;
            }
        } else if (*ptr == 'x') {
            coef[0] += sinal;
            sinal = 1;
            encontrouX = 1;
            ptr++;
        } else if (*ptr == 'y') {
            coef[1] += sinal;
            sinal = 1;
            encontrouY = 1;
            ptr++;
        } else if (*ptr == '=') {
            encontrouIgual = 1;
            sinal = 1;
            ptr++;
        } else {
            ptr++;
        }
    }

    if (!encontrouX) coef[0] = 0;
    if (!encontrouY) coef[1] = 0;

    return 1;
}

int extrairCoeficientes3x3(char* equacao, double* coef) {
    int encontrouX = 0, encontrouY = 0, encontrouZ = 0, encontrouIgual = 0;
    char* ptr = equacao;
    coef[0] = coef[1] = coef[2] = coef[3] = 0;
    double valor;
    int sinal = 1;

    while (*ptr != '\0') {
        if (*ptr == ' ') {
            ptr++;
            continue;
        }
        if (*ptr == '+') {
            sinal = 1;
            ptr++;
        } else if (*ptr == '-') {
            sinal = -1;
            ptr++;
        } else if (isdigit(*ptr) || *ptr == '.') {
            valor = strtod(ptr, &ptr);
            valor *= sinal;
            sinal = 1;
            if (*ptr == 'x') {
                coef[0] += valor;
                encontrouX = 1;
                ptr++;
            } else if (*ptr == 'y') {
                coef[1] += valor;
                encontrouY = 1;
                ptr++;
            } else if (*ptr == 'z') {
                coef[2] += valor;
                encontrouZ = 1;
                ptr++;
            } else if (encontrouIgual) {
                coef[3] += valor;
            }
        } else if (*ptr == 'x') {
            coef[0] += sinal;
            sinal = 1;
            encontrouX = 1;
            ptr++;
        } else if (*ptr == 'y') {
            coef[1] += sinal;
            sinal = 1;
            encontrouY = 1;
            ptr++;
        } else if (*ptr == 'z') {
            coef[2] += sinal;
            sinal = 1;
            encontrouZ = 1;
            ptr++;
        } else if (*ptr == '=') {
            encontrouIgual = 1;
            sinal = 1;
            ptr++;
        } else {
            ptr++;
        }
    }

    if (!encontrouX) coef[0] = 0;
    if (!encontrouY) coef[1] = 0;
    if (!encontrouZ) coef[2] = 0;

    return 1;
}

int eliminacaoGauss(int dim, double mat[MAX_DIM][MAX_DIM + 1], double sol[MAX_DIM]) {
    int i, j, k;

    for (i = 0; i < dim; i++) {
        if (fabs(mat[i][i]) < EPSILON) {
            int trocou = 0;
            for (j = i + 1; j < dim; j++) {
                if (fabs(mat[j][i]) > EPSILON) {
                    for (k = i; k < dim + 1; k++) {
                        double temp = mat[i][k];
                        mat[i][k] = mat[j][k];
                        mat[j][k] = temp;
                    }
                    trocou = 1;
                    break;
                }
            }
            if (!trocou) {
                return 0;
            }
        }

        double piv = mat[i][i];
        for (k = i; k < dim + 1; k++) {
            mat[i][k] /= piv;
        }

        for (j = 0; j < dim; j++) {
            if (j != i) {
                double fator = mat[j][i];
                for (k = i; k < dim + 1; k++) {
                    mat[j][k] -= fator * mat[i][k];
                }
            }
        }
    }

    for (i = 0; i < dim; i++) {
        sol[i] = mat[i][dim];
    }

    return 1;
}

void executarSistema() {
    limparTela();
    int dim, i, j;
    char equacoes[3][256];
    double mat[MAX_DIM][MAX_DIM + 1];
    double coeficientes[MAX_DIM][MAX_DIM]; // Matriz de coeficientes para injetividade/bijetividade
    double sol[MAX_DIM];
    double autovalores[MAX_DIM];
    double autovetoresMat[MAX_DIM][MAX_DIM];
   

    // Abre o arquivo para adicionar dados
    FILE *arquivo = fopen("main.txt", "a");
    if (arquivo == NULL) {
        printf("Erro ao abrir o arquivo para escrita!\n");
        return;
    }

    // Cabeçalho no arquivo
    fprintf(arquivo, "====================================\n");
    fprintf(arquivo, "   SISTEMAS LINEARES                \n");
    fprintf(arquivo, "====================================\n");

    // Cabeçalho na tela
    printf("SISTEMAS LINEARES\n");

    // Solicitação de dimensão do sistema
    printf("Escolha a dimensao de seus sistemas (2 ou 3): ");
    fprintf(arquivo, "Escolha a dimensao de seus sistemas (2 ou 3): ");
    scanf("%d", &dim);
    getchar();

    // Verifica se a dimensão é válida
    if (dim < 2 || dim > 3) {
        printf("Numero de variaveis invalido. Apenas 2 ou 3 sao suportados.\n");
        fprintf(arquivo, "Numero de variaveis invalido. Apenas 2 ou 3 sao suportados.\n");
        fclose(arquivo);
        return;
    }

    fprintf(arquivo, "Dimensao: %d\n", dim);

    // Entrada das equações
    for (i = 0; i < dim; i++) {
        printf("Digite a equacao %d (Ex: 1x + 1y = 2): ", i + 1);
        fprintf(arquivo, "Digite a equacao %d: ", i + 1);
        fgets(equacoes[i], sizeof(equacoes[i]), stdin);
        equacoes[i][strcspn(equacoes[i], "\n")] = 0;
        fprintf(arquivo, "%s\n", equacoes[i]);
    }

    // Extrair coeficientes das equações
    for (i = 0; i < dim; i++) {
        if (dim == 2) {
            extrairCoeficientes2x2(equacoes[i], mat[i]);
        } else {
            extrairCoeficientes3x3(equacoes[i], mat[i]);
        }
        // Preencher a matriz de coeficientes (sem os termos independentes)
        for (j = 0; j < dim; j++) {
            coeficientes[i][j] = mat[i][j];
        }
    }

    // Imprime a matriz original (com os termos independentes)
    fprintf(arquivo, "\nMatriz Original:\n");
    printf("\nMatriz Original:\n");
    imprimirMatrizComSolucoes(dim, mat, sol, 0, arquivo);

    // Resolver o sistema de equações
    int resultadoEliminacao = eliminacaoGauss(dim, mat, sol);

    // Verifica se o sistema tem solução
    if (resultadoEliminacao) {
        printf("Solucoes:\n");
        fprintf(arquivo, "Solucoes:\n");
        imprimirMatrizComSolucoes(dim, mat, sol, 1, arquivo);
        fprintf(arquivo, "====================================\n\n\n");
    } else {
        printf("O sistema parece ser indeterminado ou inconsistente.\n");
        fprintf(arquivo, "O sistema parece ser indeterminado ou inconsistente.\n");
        fprintf(arquivo, "====================================\n\n\n");
    }

    // Calcular autovalores e autovetores da matriz de coeficientes
    calcularTodosAutovaloresAutovetores(dim, coeficientes, autovalores, autovetoresMat);

    // Exibir autovalores
    printf("\nAutovalores:\n");
    fprintf(arquivo, "\nAutovalores:\n");
    for (i = 0; i < dim; i++) {
        printf("Autovalor %d: %.4lf\n", i + 1, autovalores[i]);
        fprintf(arquivo, "Autovalor %d: %.4lf\n", i + 1, autovalores[i]);
    }

    // Exibir autovetores
    printf("\nAutovetores Associados:\n");
    fprintf(arquivo, "\nAutovetores Associados:\n");
    for (i = 0; i < dim; i++) {
        printf("Autovetor %d: [ ", i + 1);
        fprintf(arquivo, "Autovetor %d: [ ", i + 1);
        for (j = 0; j < dim; j++) {
            printf("%.4lf ", autovetoresMat[j][i]);
            fprintf(arquivo, "%.4lf ", autovetoresMat[j][i]);
        }
        printf("]\n\n");
        fprintf(arquivo, "]\n\n");
    }

    // Diagonalizar a matriz de coeficientes
    double matrizDiagonal[MAX_DIM][MAX_DIM] = {0};
    for (i = 0; i < dim; i++) {
        matrizDiagonal[i][i] = autovalores[i];
    }
    
    // Imprimir a matriz diagonal
    printf("\nMatriz Diagonal:\n");
    fprintf(arquivo, "\nMatriz Diagonal:\n");
    imprimirMatriz(dim, matrizDiagonal, arquivo);

    // Exibir a matriz de mudança de base (autovetores)
    printf("\nMatriz de Mudança de Base (Autovetores):\n");
    fprintf(arquivo, "\nMatriz de Mudanca de Base (Autovetores):\n");
    for (i = 0; i < dim; i++) {
        printf("| ");
        fprintf(arquivo, "| ");
        for (j = 0; j < dim; j++) {
            printf("%8.4lf ", autovetoresMat[j][i]);
            fprintf(arquivo, "%8.4lf ", autovetoresMat[j][i]);
        }
        printf("|\n\n");
        fprintf(arquivo, "|\n\n");
    }

    //--------------------------------------
    // Verificar injetividade e bijetividade com eliminação de Gauss
    int ehBijetivo = eliminacaoGaussMatriz(dim, coeficientes);
    int ehInjetivo = 1;  // Supondo injetividade
    int ehSobrejetivo = 1;  // Supondo sobrejetividade

    // Verificação específica de injetividade e sobrejetividade
    if (!ehBijetivo) {
        if (dim == 2 && (coeficientes[1][0] == 0 && coeficientes[1][1] == 0)) {
            ehInjetivo = 0;  // Não é injetivo
            printf("O sistema e sobrejetivo, mas nao injetivo.\n");
            fprintf(arquivo, "O sistema e sobrejetivo, mas nao injetivo.\n");
        } else if (dim == 2 && (coeficientes[0][0] == 0 && coeficientes[0][1] == 0)) {
            ehSobrejetivo = 0;  // Não é sobrejetivo
            printf("O sistema e injetivo, mas nao sobrejetivo.\n");
            fprintf(arquivo, "O sistema e injetivo, mas não sobrejetivo.\n");
        } else {
            ehInjetivo = 0;
            ehSobrejetivo = 0;
        }
    }

    // Se o sistema é bijetivo (injetivo e sobrejetivo)
    if (ehBijetivo) {
        printf("O sistema eh bijetivo \n");
        fprintf(arquivo, "O sistema eh bijetivo \n");
    } else if (ehInjetivo) {
        printf("O sistema eh injetivo.\n");
        fprintf(arquivo, "O sistema eh injetivo.\n");
    } else if (ehSobrejetivo) {
        printf("O sistema eh sobrejetivo.\n");
        fprintf(arquivo, "O sistema eh sobrejetivo.\n");
    } else {
        printf("O sistema nao eh injetivo nem sobrejetivo.\n");
        fprintf(arquivo, "O sistema nao eh injetivo nem sobrejetivo.\n");
    }

    // Adiciona a verificação da base
    int dimensaoBase = verificarBase(dim, autovetoresMat);
    if (dimensaoBase == dim) {
        printf("Os vetores formam uma base do espaco.\n");
        fprintf(arquivo, "Os vetores formam uma base do espaco.\n");
    } else {
        printf("Os vetores nao formam uma base do espaco. Dimensao da base: %d\n", dimensaoBase);
        fprintf(arquivo, "Os vetores nao formam uma base do espaco. Dimensao da base: %d\n", dimensaoBase);
    }

    // Encerramento do arquivo
    fprintf(arquivo, "====================================\n");
    fclose(arquivo);
    Menu();
}

// Funções para verificação de injetividade
int eliminacaoGaussMatriz(int dim, double mat[MAX_DIM][MAX_DIM]) {
    int i, j, k;
    int rank = 0;

    for (i = 0; i < dim; i++) {
        if (fabs(mat[i][i]) < EPSILON) {
            int trocou = 0;
            for (j = i + 1; j < dim; j++) {
                if (fabs(mat[j][i]) > EPSILON) {
                    for (k = i; k < dim; k++) {
                        double temp = mat[i][k];
                        mat[i][k] = mat[j][k];
                        mat[j][k] = temp;
                    }
                    trocou = 1;
                    break;
                }
            }
            if (!trocou) {
                return 0;
            }
        }

        double piv = mat[i][i];
        for (k = i; k < dim; k++) {
            mat[i][k] /= piv;
        }

        for (j = 0; j < dim; j++) {
            if (j != i) {
                double fator = mat[j][i];
                for (k = i; k < dim; k++) {
                    mat[j][k] -= fator * mat[i][k];
                }
            }
        }

        rank++;
    }

    return (rank == dim) ? 1 : 0;
}

int Injetividade() {
    limparTela();
    int dim, i, j;
    double mat[MAX_DIM][MAX_DIM];

    // Abre o arquivo para adicionar dados
    FILE *arquivo = fopen("main.txt", "a");
    if (arquivo == NULL) {
        printf("Erro ao abrir o arquivo para escrita!\n");
        return 1;
    }

    // Cabeçalho no arquivo
    fprintf(arquivo, "====================================\n");
    fprintf(arquivo, "INJETIVIDADE, SOBREJETIVIDADE E BIJETIVIDADE\n");
    fprintf(arquivo, "====================================\n");

    // Cabeçalho na tela
    printf("INJETIVIDADE, SOBREJETIVIDADE E BIJETIVIDADE\n");

    // Solicitação de dimensão da matriz
    printf("Escolha a dimensao da matriz (2 ou 3): ");
    fprintf(arquivo, "Escolha a dimensao da matriz (2 ou 3): ");
    scanf("%d", &dim);
    getchar();

    // Verifica se a dimensão é válida
    if (dim < 2 || dim > 3) {
        printf("Numero de variaveis invalido. Apenas 2 ou 3 sao suportados.\n");
        fprintf(arquivo, "Numero de variaveis invalido. Apenas 2 ou 3 sao suportados.\n");
        fclose(arquivo);
        return 1;
    }

    fprintf(arquivo, "Dimensao: %d\n", dim);

    // Entrada dos elementos da matriz
    printf("Digite os elementos da matriz %dx%d:\n", dim, dim);
    fprintf(arquivo, "Digite os elementos da matriz %dx%d:\n", dim, dim);
    for (i = 0; i < dim; i++) {
        for (j = 0; j < dim; j++) {
            printf("Elemento [%d][%d]: ", i + 1, j + 1);
            fprintf(arquivo, "Elemento [%d][%d]: ", i + 1, j + 1);
            scanf("%lf", &mat[i][j]);
            fprintf(arquivo, "%.4lf ", mat[i][j]);
        }
        fprintf(arquivo, "\n");
    }

    // Imprime a matriz inicial
    fprintf(arquivo, "\nMatriz Inicial:\n");
    printf("\nMatriz Inicial:\n");
    imprimirMatriz(dim, mat, arquivo);

    // Resolve a matriz usando eliminação de Gauss
    if (eliminacaoGaussMatriz(dim, mat)) {
        printf("A matriz eh bijetiva (injetiva e sobrejetiva).\n");
        fprintf(arquivo, "A matriz eh bijetiva (injetiva e sobrejetiva).\n");
    } else {
        // Verifica se é apenas injetiva ou sobrejetiva
        printf("A matriz nao eh bijetiva.\n");
        fprintf(arquivo, "A matriz nao eh bijetiva.\n");

        if (dim == 2 && (mat[1][0] == 0 && mat[1][1] == 0)) {
            printf("A matriz eh sobrejetiva mas nao injetiva.\n");
            fprintf(arquivo, "A matriz eh sobrejetiva mas nao injetiva.\n");
        } else {
            printf("A matriz eh injetiva mas nao sobrejetiva.\n");
            fprintf(arquivo, "A matriz eh injetiva mas nao sobrejetiva.\n");
        }
    }

    // Finaliza o arquivo
    fprintf(arquivo, "====================================\n\n\n");
    fclose(arquivo);

    // Retorna ao menu
    Menu();
    return 0;
}

// Funções para determinação de bases
double determinante2x2(double mat[2][2]) {
    return mat[0][0] * mat[1][1] - mat[0][1] * mat[1][0];
}

double determinante3x3(double mat[3][3]) {
    return mat[0][0] * (mat[1][1] * mat[2][2] - mat[1][2] * mat[2][1]) -
           mat[0][1] * (mat[1][0] * mat[2][2] - mat[1][2] * mat[2][0]) +
           mat[0][2] * (mat[1][0] * mat[2][1] - mat[1][1] * mat[2][0]);
}

int verificarBase(int dim, double vetores[MAX_DIM][MAX_DIM]) {
    if (dim == 2) {
        double mat[2][2] = { {vetores[0][0], vetores[0][1]},
                             {vetores[1][0], vetores[1][1]} };
        double det = determinante2x2(mat);
        return fabs(det) > EPSILON;
    } else if (dim == 3) {
        double det = determinante3x3(vetores);
        return fabs(det) > EPSILON;
    }
    return 0;
}

int base() {
    limparTela();
    int dim;
    double vetores[MAX_DIM][MAX_DIM];
    FILE *arquivo = fopen("main.txt", "a");
    if (arquivo == NULL) {
        printf("Erro ao abrir o arquivo para escrita!\n");
        return 1;
    }

    fprintf(arquivo, "====================================\n");
    fprintf(arquivo, "   BASES DE ESPACOS VETORIAIS        \n");
    fprintf(arquivo, "====================================\n");

    printf("BASES DE ESPACOS VETORIAIS\n");
    printf("Escolha a dimensao do espaco vetorial (2 ou 3): ");
    fprintf(arquivo, "Escolha a dimensao do espaco vetorial (2 ou 3): ");
    scanf("%d", &dim);
    getchar();

    if (dim < 2 || dim > 3) {
        printf("Dimensao invalida. Apenas 2 ou 3 sao suportadas.\n");
        fprintf(arquivo, "Dimensao invalida. Apenas 2 ou 3 sao suportadas.\n");
        fclose(arquivo);
        return 1;
    }

    fprintf(arquivo, "Dimensao: %d\n", dim);

    printf("Digite os vetores:\n");
    fprintf(arquivo, "Digite os vetores:\n");

    for (int i = 0; i < dim; i++) {
        printf("Vetor [%d]: ", i + 1);
        fprintf(arquivo, "Vetor [%d]: ", i + 1);
        for (int j = 0; j < dim; j++) {
            scanf("%lf", &vetores[i][j]);
            fprintf(arquivo, "%.2f ", vetores[i][j]);
        }
        fprintf(arquivo, "\n");
        printf("\n");
    }

    if (verificarBase(dim, vetores)) {
        printf("Os vetores formam uma base para o espaco vetorial de dimensao %d.\n", dim);
        fprintf(arquivo, "Os vetores formam uma base para o espaco vetorial de dimensao %d.\n", dim);
    } else {
        printf("Os vetores nao formam uma base para o espaco vetorial de dimensao %d.\n", dim);
        fprintf(arquivo, "Os vetores nao formam uma base para o espaco vetorial de dimensao %d.\n", dim);
    }

    fprintf(arquivo, "====================================\n\n\n");
    fclose(arquivo);
    Menu();
    return 0;
}

// Funções para cálculo de autovalores e autovetores
void multiplicarMatrizVetor(int dim, double mat[MAX_DIM][MAX_DIM], double vetor[MAX_DIM], double resultado[MAX_DIM]) {
    for (int i = 0; i < dim; i++) {
        resultado[i] = 0;
        for (int j = 0; j < dim; j++) {
            resultado[i] += mat[i][j] * vetor[j];
        }
    }
}

void normalizarVetor(int dim, double vetor[MAX_DIM]) {
    double norma = 0.0;
    for (int i = 0; i < dim; i++) {
        norma += vetor[i] * vetor[i];
    }
    norma = sqrt(norma);
    if (norma > EPSILON) {
        for (int i = 0; i < dim; i++) {
            vetor[i] /= norma;
        }
    }
}

double calcularAutovalorAutovetor(int dim, double mat[MAX_DIM][MAX_DIM], double vetor[MAX_DIM]) {
    double resultado[MAX_DIM];
    multiplicarMatrizVetor(dim, mat, vetor, resultado);

    double numerador = 0.0, denominador = 0.0;
    for (int i = 0; i < dim; i++) {
        numerador += vetor[i] * resultado[i];
        denominador += vetor[i] * vetor[i];
    }

    if (fabs(denominador) > EPSILON) {
        return numerador / denominador;
    } else {
        return 0.0;
    }
}

void deflacionarMatriz(int dim, double mat[MAX_DIM][MAX_DIM], double autovalor, double autovetor[MAX_DIM]) {
    for (int i = 0; i < dim; i++) {
        for (int j = 0; j < dim; j++) {
            mat[i][j] -= autovalor * autovetor[i] * autovetor[j];
        }
    }
}

void calcularTodosAutovaloresAutovetores(int dim, double mat[MAX_DIM][MAX_DIM], double autovalores[MAX_DIM], double autovetores[MAX_DIM][MAX_DIM]) {
    double vetorInicial[MAX_DIM];
    double matrizTemp[MAX_DIM][MAX_DIM];

    for (int i = 0; i < dim; i++) {
        for (int j = 0; j < dim; j++) {
            matrizTemp[i][j] = mat[i][j];
        }
    }

    for (int k = 0; k < dim; k++) {
        for (int i = 0; i < dim; i++) {
            vetorInicial[i] = 1.0;
        }

        double autovalorAtual = 0.0, autovalorAnterior = 1.0;
        int iteracoes = 0;

        while (fabs(autovalorAtual - autovalorAnterior) > EPSILON && iteracoes < MAX_ITER) {
            autovalorAnterior = autovalorAtual;
            multiplicarMatrizVetor(dim, matrizTemp, vetorInicial, vetorInicial);
            normalizarVetor(dim, vetorInicial);
            autovalorAtual = calcularAutovalorAutovetor(dim, matrizTemp, vetorInicial);
            iteracoes++;
        }

        autovalores[k] = autovalorAtual;
        for (int i = 0; i < dim; i++) {
            autovetores[i][k] = vetorInicial[i];
        }

        deflacionarMatriz(dim, matrizTemp, autovalorAtual, vetorInicial);
    }
}

void imprimirMatrizDiagonal(int dim, double autovalores[MAX_DIM]) {
    printf("\nMatriz Diagonal com os Autovalores:\n");
    printf("------------------------------------\n");
    for (int i = 0; i < dim; i++) {
        printf("| ");
        for (int j = 0; j < dim; j++) {
            if (i == j) {
                printf("%8.4lf ", autovalores[i]);
            } else {
                printf("%8.4lf ", 0.0);
            }
        }
        printf("|\n");
    }
    printf("------------------------------------\n");
}

int autovetores() {
    limparTela();
    int dim, i, j;
    double mat[MAX_DIM][MAX_DIM];
    double autovalores[MAX_DIM];
    double autovetoresMat[MAX_DIM][MAX_DIM];

    FILE *arquivo = fopen("main.txt", "a");
    if (arquivo == NULL) {
        printf("Erro ao abrir o arquivo para escrita!\n");
        return 1;
    }

    fprintf(arquivo, "====================================\n");
    fprintf(arquivo, "   AUTOVETORES E AUTOVALORES         \n");
    fprintf(arquivo, "====================================\n");

    printf("AUTOVETORES E AUTOVALORES\n");
    printf("Escolha a dimensao da matriz (2 ou 3): ");
    fprintf(arquivo, "Escolha a dimensao da matriz (2 ou 3): ");
    scanf("%d", &dim);
    getchar();

    if (dim < 2 || dim > 3) {
        printf("Numero de variaveis invalido. Apenas 2 ou 3 sao suportados.\n");
        fprintf(arquivo, "Numero de variaveis invalido. Apenas 2 ou 3 sao suportados.\n");
        fclose(arquivo);
        return 1;
    }

    fprintf(arquivo, "Dimensao: %d\n", dim);

    printf("Digite os elementos da matriz %dx%d:\n", dim, dim);
    fprintf(arquivo, "Digite os elementos da matriz %dx%d:\n", dim, dim);
    for (i = 0; i < dim; i++) {
        for (j = 0; j < dim; j++) {
            printf("Elemento [%d][%d]: ", i + 1, j + 1);
            fprintf(arquivo, "Elemento [%d][%d]: ", i + 1, j + 1);
            scanf("%lf", &mat[i][j]);
            fprintf(arquivo, "%.4lf ", mat[i][j]);
        }
        fprintf(arquivo, "\n");
    }

    fprintf(arquivo, "\nMatriz Inicial:\n");
    printf("\nMatriz Inicial:\n");
    imprimirMatriz(dim, mat, arquivo);

    calcularTodosAutovaloresAutovetores(dim, mat, autovalores, autovetoresMat);

    printf("\nAutovalores:\n");
    fprintf(arquivo, "\nAutovalores:\n");
    for (i = 0; i < dim; i++) {
        printf("Autovalor %d: %.4lf\n", i + 1, autovalores[i]);
        fprintf(arquivo, "Autovalor %d: %.4lf\n", i + 1, autovalores[i]);
    }

    printf("\nAutovetores Associados:\n");
    fprintf(arquivo, "\nAutovetores Associados:\n");
    for (i = 0; i < dim; i++) {
        printf("Autovetor %d: [ ", i + 1);
        fprintf(arquivo, "Autovetor %d: [ ", i + 1);
        for (j = 0; j < dim; j++) {
            printf("%.4lf ", autovetoresMat[j][i]);
            fprintf(arquivo, "%.4lf ", autovetoresMat[j][i]);
        }
        printf("]\n");
        fprintf(arquivo, "]\n");
    }

    fprintf(arquivo, "====================================\n\n\n");
    fclose(arquivo);
    Menu();
    return 0;
}

// Funções para diagonalização
void diagonalizar(int dim, double mat[MAX_DIM][MAX_DIM], FILE *arquivo) {
    double autovalores[MAX_DIM];
    double autovetores[MAX_DIM][MAX_DIM];

    calcularTodosAutovaloresAutovetores(dim, mat, autovalores, autovetores);

    double matrizDiagonal[MAX_DIM][MAX_DIM] = {0};
    for (int i = 0; i < dim; i++) {
        matrizDiagonal[i][i] = autovalores[i];
    }

    fprintf(arquivo, "\nMatriz Diagonal:\n");
    printf("\nMatriz Diagonal:\n");
    imprimirMatriz(dim, matrizDiagonal, arquivo);

    fprintf(arquivo, "\nMatriz de Mudanca de Base (Autovetores):\n");
    printf("\nMatriz de Mudanca de Base (Autovetores):\n");
    for (int i = 0; i < dim; i++) {
        printf("| ");
        fprintf(arquivo, "| ");
        for (int j = 0; j < dim; j++) {
            printf("%8.4lf ", autovetores[j][i]);
            fprintf(arquivo, "%8.4lf ", autovetores[j][i]);
        }
        printf("|\n");
        fprintf(arquivo, "|\n");
    }
}

int diagonalizarExecute() {
    limparTela();
    int dim, i, j;
    double mat[MAX_DIM][MAX_DIM];

    FILE *arquivo = fopen("main.txt", "a");
    if (arquivo == NULL) {
        printf("Erro ao abrir o arquivo para escrita!\n");
        return 1;
    }

    fprintf(arquivo, "====================================\n");
    fprintf(arquivo, "       DIAGONALIZACAO DE MATRIZES       \n");
    fprintf(arquivo, "====================================\n");

    printf("DIAGONALIZACAO DE MATRIZES\n");
    printf("Escolha a dimensao da matriz (2 ou 3): ");
    fprintf(arquivo, "Escolha a dimensao da matriz (2 ou 3): ");
    scanf("%d", &dim);
    getchar();

    if (dim < 2 || dim > 3) {
        printf("Numero de variaveis invalido. Apenas 2 ou 3 sao suportados.\n");
        fprintf(arquivo, "Numero de variaveis invalido. Apenas 2 ou 3 sao suportados.\n");
        fclose(arquivo);
        return 1;
    }

    fprintf(arquivo, "Dimensao: %d\n", dim);

    printf("Digite os elementos da matriz %dx%d:\n", dim, dim);
    fprintf(arquivo, "Digite os elementos da matriz %dx%d:\n", dim, dim);
    for (i = 0; i < dim; i++) {
        for (j = 0; j < dim; j++) {
            printf("Elemento [%d][%d]: ", i + 1, j + 1);
            fprintf(arquivo, "Elemento [%d][%d]: ", i + 1, j + 1);
            scanf("%lf", &mat[i][j]);
            fprintf(arquivo, "%.4lf ", mat[i][j]);
        }
        fprintf(arquivo, "\n");
    }

    fprintf(arquivo, "\nMatriz Inicial:\n");
    printf("\nMatriz Inicial:\n");
    imprimirMatriz(dim, mat, arquivo);

    diagonalizar(dim, mat, arquivo);

    fprintf(arquivo, "====================================\n\n\n");
    fclose(arquivo);
    Menu();
    return 0;
}
